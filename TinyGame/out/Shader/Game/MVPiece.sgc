#include "Common.sgc"
#include "PrimitiveParam.sgc"
#include "ViewParam.sgc"

const float3 DirOffset[ 6 ] = float3[](
   float3( 1 , 0 , 0 ) , float3( -1 , 0 , 0 ) ,
   float3( 0 , 1 , 0 ) , float3( 0 , -1 , 0 ) ,
   float3( 0 , 0 , 1 ) , float3( 0 , 0 , -1 ) ); 

uniform float3 color = float3( 0.7 , 0.8 , 0.75 );
uniform float3 LightDir = float3( 0.4 , 0.5 , 0.8 );
uniform float3 LocalScale = float3( 1 , 1 , 1 );
uniform int2 Rotation = int2(0,4);

varying float3 outColor;
varying float3 normal;


struct OutputVSParam
{
	float3 normal;
};


#if VERTEX_SHADER

DECLARE_VERTEX_INPUT(float3, pos, ATTRIBUTE_POSITION)
DECLARE_VERTEX_INPUT(float3, normal, ATTRIBUTE_NORMAL)
out OutputVSParam OutputVS;
void MainVS()
{
	
	float3 axisX = DirOffset[Rotation.x];
	float3 axisZ = DirOffset[Rotation.y];
	float3 axisY = cross( axisZ , axisX );

	float4x4 localScale = float4x4(
		float4( LocalScale.x * axisX , 0 ) , 
		float4( LocalScale.y * axisY , 0 ) , 
		float4( LocalScale.z * axisZ , 0 ) , 
		float4( 0,0,0,1) );

	float4x4 localToWorld = Primitive.localToWorld * localScale;
	// NormalMatrix = ( inverse( localToWorld ) )^t
	OutputVS.normal = VERTEX_INPUT(normal) * float3x3( inverse(localToWorld) );

	gl_Position = View.worldToClip * localToWorld * float4( VERTEX_INPUT(pos) , 1 );
}

#endif //VERTEX_SHADER

#if PIXEL_SHADER

in OutputVSParam OutputVS;
layout(location = 0) out float4 OutColor;
void MainPS() 
{
	float3 N = normalize(OutputVS.normal);
	OutColor.rgb = abs(dot(N, normalize(LightDir))) * float3(1, 1, 1);
	OutColor.a = 1;
}

#endif //PIXEL_SHADER
