#ifndef DOUBLE_SIM_SGC
#define DOUBLE_SIM_SGC

// "Industrial Grade" Robust Double-Single Math Library
// Polymorphic implementation to support Double-Double when Native Double is available.

#ifndef DS_BASE_TYPE
#define DS_BASE_TYPE float
#endif

#ifndef DS_TYPE
#define DS_TYPE float2
#endif

#undef DS_PRECISE
#define DS_PRECISE precise

// 強化版 DSAdd：針對極致縮放級別優化，確保低位不遺失
DS_PRECISE DS_TYPE DSAdd(DS_TYPE a, DS_TYPE b)
{
	DS_PRECISE DS_BASE_TYPE s = a.x + b.x;
	DS_PRECISE DS_BASE_TYPE t = s - a.x;
	DS_PRECISE DS_BASE_TYPE e = (a.x - (s - t)) + (b.x - t);
	e += (a.y + b.y);
	DS_PRECISE DS_BASE_TYPE s2 = s + e;
	DS_PRECISE DS_BASE_TYPE e2 = e + (s - s2);
	return DS_TYPE(s2, e2);
}

DS_PRECISE DS_TYPE DSSub(DS_TYPE a, DS_TYPE b)
{
	return DSAdd(a, DS_TYPE(-b.x, -b.y));
}

DS_PRECISE DS_TYPE DSMul(DS_TYPE a, DS_TYPE b)
{
	// Specific splits for different base types
#if USE_NATIVE_DOUBLE && USE_DOUBLE_SIM
	const DS_BASE_TYPE split = 134217729.0; // 2^27 + 1
#else
	const DS_BASE_TYPE split = 4097.0;       // 2^12 + 1
#endif

	DS_PRECISE DS_BASE_TYPE cona = a.x * split;
	DS_PRECISE DS_BASE_TYPE ax = cona - (cona - a.x);
	DS_PRECISE DS_BASE_TYPE ay = a.x - ax;
	DS_PRECISE DS_BASE_TYPE conb = b.x * split;
	DS_PRECISE DS_BASE_TYPE bx = conb - (conb - b.x);
	DS_PRECISE DS_BASE_TYPE by = b.x - bx;

	DS_PRECISE DS_BASE_TYPE r1 = a.x * b.x;
	DS_PRECISE DS_BASE_TYPE r2 = ay * by - (((r1 - ax * bx) - ay * bx) - ax * by);
	r2 += (a.x * b.y + a.y * b.x);

	DS_PRECISE DS_BASE_TYPE s2 = r1 + r2;
	DS_PRECISE DS_BASE_TYPE e2 = r2 + (r1 - s2);
	return DS_TYPE(s2, e2);
}

// 4D complex type: x (real.hi), y (real.lo), z (imag.hi), w (imag.lo)
#if USE_NATIVE_DOUBLE && USE_DOUBLE_SIM
  #define DS_COMPLEX_TYPE double4
#else
  #define DS_COMPLEX_TYPE float4
#endif

inline DS_COMPLEX_TYPE ComplexAdd(DS_COMPLEX_TYPE a, DS_COMPLEX_TYPE b) { return DS_COMPLEX_TYPE(DSAdd(a.xy, b.xy), DSAdd(a.zw, b.zw)); }
inline DS_COMPLEX_TYPE ComplexSub(DS_COMPLEX_TYPE a, DS_COMPLEX_TYPE b) { return DS_COMPLEX_TYPE(DSSub(a.xy, b.xy), DSSub(a.zw, b.zw)); }
inline DS_COMPLEX_TYPE ComplexMul(DS_COMPLEX_TYPE a, DS_COMPLEX_TYPE b)
{
	// 使用更高的局部精度進行複數乘法
	DS_PRECISE DS_TYPE re = DSSub(DSMul(a.xy, b.xy), DSMul(a.zw, b.zw));
	DS_PRECISE DS_TYPE im = DSAdd(DSMul(a.xy, b.zw), DSMul(a.zw, b.xy));
	return DS_COMPLEX_TYPE(re, im);
}
inline DS_TYPE ComplexAbsSquare(DS_COMPLEX_TYPE a) { return DSAdd(DSMul(a.xy, a.xy), DSMul(a.zw, a.zw)); }

inline DS_TYPE StoreValue(DS_BASE_TYPE a) { return DS_TYPE(a, 0.0); }
inline float Compare(DS_TYPE dsa, DS_TYPE dsb) { return float((dsa.x != dsb.x) ? (dsa.x - dsb.x) : (dsa.y - dsb.y)); }

#endif // DOUBLE_SIM_SGC
