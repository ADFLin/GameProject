#include "Common.sgc"
#include "ViewParam.sgc"
#include "TiledLightCommon.sgc"
#include "ScatteringCommon.sgc"
#include "LightingCommon.sgc"

//                                 o L
//                                /  \
//                               /     \  
//   cam o----------------------o------- /
//       x                      xt       xs
//
//Li(x,w) = Tr(x,xs)*Ls(xs,w0) + Integral( xs , 0 )[ Tr(x,xt) mu_t(s,x) Lscat(xt,wi)] ds
//Tr(x,xs) = exp( - Integral(xs,0)[mu_t(s,x)] ds )
//Lscat(xt,wi) = p * sum(l:lights)[ f(v,l)Vis(x,l)Li(x,l) ]
//Vis(x,l) = shadowMap(x,l) * volumetricShadowMap( x , l )
// f(v,l) ?
// mu_a : Absorption 
// mu_s : Scattering
// mu_t = mu_s + mu_a: Extinction 
// p = mu_s / mu_t: Albedo 
// g = g_m + g_k : phase
// g_mei = 1/4pi
// g_r = HG or schlick

struct FroxelVolumeData
{
	float3 scarttingColor;
	float  extinction;
	float3 emitterColor;
	float  gFactor;
};

RWTexture3D<float4> VolumeRWBufferA;
RWTexture3D<float4> VolumeRWBufferB;
void WriteVolumeBuffer(in FroxelVolumeData data , int3 pos )
{
	float4 dataA = float4(data.scarttingColor, data.extinction);
	VolumeRWBufferA[pos] = dataA;
	float4 dataB = float4(data.emitterColor, data.gFactor);
	VolumeRWBufferB[pos] = dataB;
}

Texture3D<float4> VolumeBufferA;
Texture3D<float4> VolumeBufferB;

void ReadVolumeBuffer(out FroxelVolumeData data , int3 pos )
{
	float4 dataA = VolumeBufferA.Load(int4(pos, 0));
	float4 dataB = VolumeBufferB.Load(int4(pos, 0));
	data.scarttingColor = dataA.rgb;
	data.extinction = dataA.a;
	data.emitterColor = dataB.rgb;
	data.gFactor = dataB.a;
}


RWTexture3D<float4> ScatteringRWBuffer;
Texture3D<float4> HistoryBuffer;
SamplerState HistoryBufferSampler;

#ifndef GROUP_SIZE_X
#define GROUP_SIZE_X 8
#endif
#ifndef GROUP_SIZE_Y
#define GROUP_SIZE_Y 8
#endif

// Light types matching SceneLighting.h/cpp
// Light types matching LightingCommon.sgc
#define LIGHT_SPOT LIGHTTYPE_SPOT
#define LIGHT_POINT LIGHTTYPE_POINT
#define LIGHT_DIRECTIONAL LIGHTTYPE_DIRECTIONAL

// Simple spot attenuation approximation
float SpotAttenuation(float3 l, float3 d, float2 spotParam)
{
	float cosTheta = dot(-l, d);
	return smoothstep(spotParam.y, spotParam.x, cosTheta);
}

#if COMPUTE_SHADER
CS_NUM_THREADS(GROUP_SIZE_X, GROUP_SIZE_Y, 1)
CS_ENTRY(LightScatteringCS)
{
	uint3 pos = SvDispatchThreadID.xyz;
	uint3 dim;
	ScatteringRWBuffer.GetDimensions(dim.x, dim.y, dim.z);
	if (any(pos >= dim))
		return;

	FroxelVolumeData volumeData;
	ReadVolumeBuffer(volumeData, int3(pos));

	// Interleaved Gradient Noise (IGN) - used by Frostbite, UE5
	// Better distribution than sin-based hash
	float2 screenPos = float2(pos.xy);
	float frameOffset = float(View.frameCount % 8) * 0.5;
	
	// IGN for XY
	// float ign = frac(52.9829189 * frac(0.06711056 * screenPos.x + 0.00583715 * screenPos.y + frameOffset));
	
	// Better 3D hash using bit operations (simulated with math)
	// float3 p = float3(pos) + float(View.frameCount % 64) * 0.017;
	/*
	float3 noise = float3(
		frac(sin(p.x * 127.1 + p.y * 311.7 + p.z * 74.7) * 43758.5453),
		frac(sin(p.x * 269.5 + p.y * 183.3 + p.z * 246.1) * 43758.5453),
		frac(sin(p.x * 113.5 + p.y * 271.9 + p.z * 124.6) * 43758.5453)
	);
	*/

	// DISABLE JITTER as requested by User (No TAA)
	float3 jitter = float3(0, 0, 0);
	
	float3 jitteredUVW = (float3(pos) + 0.5 + jitter) / float3(dim);
	float2 ndc = jitteredUVW.xy * 2.0 - 1.0;
	//ndc.y *= -1; // Keep the Y-flip fix!

#if USE_INVERSE_ZBUFFER
	float4 clipPosNear = float4(ndc, 1.0, 1.0);
	float4 clipPosFar = float4(ndc, 0.0, 1.0);
#else
	float4 clipPosNear = float4(ndc, 0.0, 1.0);
	float4 clipPosFar = float4(ndc, 1.0, 1.0);
#endif

	float4 viewPosFar = mul(View.clipToView, clipPosFar);
	viewPosFar /= viewPosFar.w;

	// Use camera frustum settings from View buffer
	// Keep small zNear for sharp cone tips
	float zNear = 0.1;
	float zFar = 800; // Match what seemed to work for range
	float sampleZ = jitteredUVW.z;
	float viewZ = zNear * pow(abs(zFar / zNear), sampleZ);
	
	// Reconstruct view position along the ray
	float3 viewPos = viewPosFar.xyz * (viewZ / abs(viewPosFar.z));

	float3 worldPos = mul(View.viewToWorld, float4(viewPos, 1.0)).xyz;
	float3 viewDir = normalize(worldPos - View.worldPos);

	float3 totalRadiance = float3(0, 0, 0);

	for( int i = 0; i < TiledLightNum; ++i )
	{
		TiledLightInfo light = TiledLightList[i];
		
		float3 lDir;
		float atten = 1.0;

		if (light.type == LIGHT_DIRECTIONAL)
		{
			lDir = -normalize(light.dir);
			atten = 1.0;
		}
		else
		{
			float3 toLight = light.pos - worldPos;
			float distSq = dot(toLight, toLight);
			float dist = sqrt(distSq);
			lDir = toLight / dist;
			
			if (dist > light.radius)
				atten = 0.0;
			else
			{
				atten = CalcRaidalAttenuation(dist, 1.0 / light.radius);
			}

			if (light.type == LIGHT_SPOT && atten > 0.0)
			{
				atten *= SpotAttenuation(lDir, normalize(light.dir), light.param.xy);
			}
		}

		if (atten > 0.0)
		{
			float cosTheta = dot(lDir, -viewDir);
			float phase = PhaseFunction_HG(cosTheta, volumeData.gFactor);
			
			float3 lightColor = light.color * light.intensity;
			
			// Shadow Map Sampling
			if (light.type == LIGHT_DIRECTIONAL)
			{
				// float shadow = ShadowMap.SampleLevel(ShadowSampler, shadowCoord, 0);
				// atten *= shadow; // TODO
			}
			
			totalRadiance += lightColor * phase * atten;
		}
	} // End Light Loop

	float4 currentScattering = float4(totalRadiance * volumeData.scarttingColor, volumeData.extinction);

	// Temporal Reprojection Setup
	float4 prevScattering = currentScattering;
	// TAA DISABLED
	
	// Write to ScatteringRWBuffer (mapped to RawBuffer in C++)
	ScatteringRWBuffer[pos] = prevScattering;
}

// Separate input texture to prevent race conditions during filtering
// Mapped to ScatteringRawBuffer in C++
 

CS_NUM_THREADS(GROUP_SIZE_X, GROUP_SIZE_Y, 1)
CS_ENTRY(VolumetricIntegrationCS)
{
	int2 pos = int2(SvDispatchThreadID.xy);
	uint3 dim;
	ScatteringRWBuffer.GetDimensions(dim.x, dim.y, dim.z);

	if (any(pos >= int2(dim.xy)))
		return;

	float3 accumLight = float3(0, 0, 0);
	float accumTransmittance = 1.0;
	
	// Reconstruction constants
	float zNear = 1.0;
	float zFar = 2000.0;
	float3 volDimF = float3(dim);

	// Need previous slice depth to calculate step size
	float prevSliceZ = zNear;

	for(uint z = 0; z < dim.z; ++z)
	{
		int3 cellPos = int3(pos, z);
		
		// Spatial Filter (3x3) to smooth out voxel aliasing
		// Since we disabled TAA, this is crucial for softer edges.
		float4 scat = float4(0, 0, 0, 0);
		float totalWeight = 0.0;
		
		[unroll]
		for(int x = -1; x <= 1; ++x)
		{
			[unroll]
			for(int y = -1; y <= 1; ++y)
			{
				int3 neighborPos = int3(cellPos.x + x, cellPos.y + y, cellPos.z);
				
				// Standard 3x3 Gaussian-like kernel weights
				// Center (0,0): 4, Neighbors: 2, Corners: 1
				float w = 1.0;
				if (x == 0 && y == 0) w = 4.0;
				else if (x == 0 || y == 0) w = 2.0;
				
				// Clamp to border to avoid black edges
				neighborPos.xy = clamp(neighborPos.xy, int2(0, 0), int2(dim.xy) - 1);
				
				scat += VolumeBufferA.Load(int4(neighborPos, 0)) * w;
				totalWeight += w;
			}
		}
		scat /= totalWeight;
		
		// Calculate depth at current slice center for step size approximation
		float sampleZ = (float(z) + 0.5) / volDimF.z;
		float currentSliceDepth = zNear * pow(abs(zFar / zNear), sampleZ);
		
		float stepSize = currentSliceDepth - prevSliceZ;
		prevSliceZ = currentSliceDepth; 
		
		// In-Scattered Radiance (RGB) and Extinction (A)
		float3 S = scat.rgb;
		float E = max(scat.a, 0.000001);
		
		float transmittance = exp(-E * stepSize);
		
		// Energy Conserving Integration: (S - S*T) / E
		float3 integratedScattering = (S - S * transmittance) / E;
		
		accumLight += integratedScattering * accumTransmittance;
		accumTransmittance *= transmittance;
		
		ScatteringRWBuffer[cellPos] = float4(accumLight, accumTransmittance);
	}
}
#endif

// Simple Visualization Shader
#if VERTEX_SHADER
void VolumetricVisualizationVS(
	in float2 inPos : ATTRIBUTE_POSITION,
	in float2 inUV : ATTRIBUTE_TEXCOORD,
	out float2 outUV : TEXCOORD0,
	out float4 outPos : SV_POSITION
)
{
	outUV = inUV;
	outPos = float4(inPos, 0, 1);
}
#endif

#if PIXEL_SHADER
DEFINE_TEXTURE( Texture3D, ScatteringBuffer );
DEFINE_TEXTURE( Texture2D, SceneDepthTexture );

void VolumetricVisualizationPS(
	in float2 uv : TEXCOORD0,
	out float4 outColor : SV_Target0
)
{
	float zNear = 0.01;
	float zFar = 800.0;

	// Read scene depth with flipped Y (D3D/OpenGL coordinate correction)
	float2 depthUV = float2(uv.x, 1.0 - uv.y);
	float deviceDepth = SceneDepthTexture.Sample(ScatteringBufferSampler, depthUV).r;
	
	// Reconstruction from Projection Matrix (Robust method)
	float A = View.viewToClip[2][2];
	float B = View.viewToClip[2][3];
	float sceneDepth = abs(B / (deviceDepth - A));
	
	// Calculate Froxel Z [0, 1] using exponential distribution
	float froxelZ = log(max(zNear, sceneDepth) / zNear) / log(zFar / zNear);
	froxelZ = saturate(froxelZ);

	// Manual Trilinear Interpolation because hardware sampler seems unreliable
	float3 volDim;
	ScatteringBuffer.GetDimensions(volDim.x, volDim.y, volDim.z);

	// Robust Center-aligned sampling
	// Map froxelZ [0, 1] exactly to [0, dim-1]
	float3 uvw = float3(uv, froxelZ);
	float3 texCoord;
	texCoord.xy = uvw.xy * volDim.xy - 0.5; 
	texCoord.z  = uvw.z  * (volDim.z - 1.0);

	float3 baseFloor = floor(texCoord);
	float3 fraction = texCoord - baseFloor; // Weights for interpolation

	// Smoothstep weights for softer appearance (bicubic-like)
	float3 w = smoothstep(0.0, 1.0, fraction);

	// Fetch 8 neighbors with clamping
	int3 maxDim = int3(volDim) - 1;
	
	// Helper to load with boundary check
	// With the new mapping, Z is guaranteed to be in [0, maxDim], but we keep clamp for safety
	#define LOAD_SAFE(idx) ScatteringBuffer.Load(int4(clamp(idx, int3(0,0,0), maxDim), 0))

	int3 t0 = int3(baseFloor);
	int3 t1 = t0 + int3(1, 0, 0); 
	int3 t2 = t0 + int3(0, 1, 0); 
	int3 t3 = t0 + int3(1, 1, 0); 
	
	int3 t4 = t0 + int3(0, 0, 1); 
	int3 t5 = t1 + int3(0, 0, 1);
	int3 t6 = t2 + int3(0, 0, 1);
	int3 t7 = t3 + int3(0, 0, 1);

	float4 c0 = LOAD_SAFE(t0);
	float4 c1 = LOAD_SAFE(t1);
	float4 c2 = LOAD_SAFE(t2);
	float4 c3 = LOAD_SAFE(t3);
	float4 c4 = LOAD_SAFE(t4);
	float4 c5 = LOAD_SAFE(t5);
	float4 c6 = LOAD_SAFE(t6);
	float4 c7 = LOAD_SAFE(t7);

	// Z-slice interpolation
	float4 bottom = lerp(lerp(c0, c1, w.x), lerp(c2, c3, w.x), w.y);
	float4 top    = lerp(lerp(c4, c5, w.x), lerp(c6, c7, w.x), w.y);
	
	float4 fog = lerp(bottom, top, w.z);
	
	// Simple Dithering to break banding
	float dither = frac(sin(dot(uv.xy * volDim.xy, float2(12.9898, 78.233))) * 43758.5453) - 0.5;
	fog.rgb += dither * (1.0/255.0); // 8-bit dither

	outColor = fog;

	// DEBUG: Uncomment the line below to visualize the depth buffer (black = near, white = far)
	// outColor = float4(froxelZ.xxx, 1.0);
}
#endif
