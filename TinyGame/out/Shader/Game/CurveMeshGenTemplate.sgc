#include "Common.sgc"


#define TYPE_SURFACE_XY 1
#define TYPE_SURFACE_UV 2

#ifndef FUNC_TYPE
#define FUNC_TYPE TYPE_SURFACE_XY
#endif

struct GenParamsData
{
	float2 delata;
	float2 offset;
	uint   gridCountU;
	uint   vertexCount;
	uint   vertexSize;
	uint   posOffset;
	float  time;
	float3 dummy;
};

#if SHADER_COMPILING
layout(std140) cbuffer GenParamsDataBlock
{
	GenParamsData GenParams;
};
#else
uniform GenParamsData GenParams;
#endif

#if FUNC_TYPE == TYPE_SURFACE_XY
float Func(float x, float y, float t)
#else
float FuncX(float u, float v, float t)
#endif
{
	return %s;
}

#if FUNC_TYPE == TYPE_SURFACE_UV
float FuncY(float u, float v, float t)
{
	return %s;
}
float FuncZ(float u, float v, float t)
{
	return %s;
}
#endif

#if COMPUTE_SHADER

#if COMPILER_HLSL
RWBuffer<float> VertexOutput;
#else
layout(std430) buffer VertexOutputBuffer
{
	float VertexOutput[];
};
#endif

CS_NUM_THREADS(16, 1, 1)
CS_ENTRY(GenVertexCS)
{
	uint vertexId = SvDispatchThreadID.x;

	if (vertexId >= GenParams.vertexCount)
		return;

	float2 uv = GenParams.offset + float2( vertexId / GenParams.gridCountU, vertexId % GenParams.gridCountU) * GenParams.delata;
	uint vertexIndex = vertexId * GenParams.vertexSize + GenParams.posOffset;

#if FUNC_TYPE == TYPE_SURFACE_XY
	VertexOutput[vertexIndex + 0] = uv.x;
	VertexOutput[vertexIndex + 1] = uv.y;
	VertexOutput[vertexIndex + 2] = Func(uv.x, uv.y, GenParams.time);
#elif FUNC_TYPE == TYPE_SURFACE_UV
	VertexOutput[vertexIndex + 0] = FuncX(uv.x, uv.y, GenParams.time);
	VertexOutput[vertexIndex + 1] = FuncY(uv.x, uv.y, GenParams.time);
	VertexOutput[vertexIndex + 2] = FuncZ(uv.x, uv.y, GenParams.time);
#endif
}

#endif