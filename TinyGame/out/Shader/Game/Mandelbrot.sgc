#include "Common.sgc"
#include "ComplexCommon.sgc"

#if COMPUTE_SHADER

cbuffer MParamsBlock
{
uniform float4 CoordParam;  //xy = center pos , zw = min pos ;
uniform float4 CoordParam2; //xy = dx dy , zw = rect rotation cos sin;
uniform float4 ColorMapParam; // x = density , y = color rotation , bailoutSquare;
uniform int   MaxIteration;
uniform int2  ViewSize;
}

#if COMPILER_HLSL
RWTexture2D< float4 > ColorRWTexture;
#else
layout(rgba32f) uniform writeonly image2D  ColorRWTexture;
//layout(r32ui) uniform writeonly uimage2D IteratorRWTexture;
#endif
DEFINE_TEXTURE( Texture1D , ColorMapTexture );

#ifndef SIZE_X
#define SIZE_X 8
#endif
#ifndef SIZE_Y
#define SIZE_Y 8
#endif

CS_NUM_THREADS(16, 16, 1)
CS_ENTRY(MainCS)
{
	int2 pixelPos = int2(SvDispatchThreadID.xy);
	float2 uv = float2(SvDispatchThreadID.xy) / ViewSize;
	if( pixelPos.x >= ViewSize.x || pixelPos.y >= ViewSize.y )
		return;

	float2 pos = CoordParam.zw + float2(pixelPos) * CoordParam2.xy;
	float2x2 m = float2x2( CoordParam2.zw, float2(-CoordParam2.w, CoordParam2.z));
	float2 z0 = CoordParam.xy + mul( m , ( pos - CoordParam.xy ));

	float2 z = z0;
	int iteration = 0;
	float rSquare = 0;

	LOOP
	while( rSquare < ColorMapParam.z && iteration < MaxIteration )
	{
		z = ComplexMul(z, z) + z0;
		rSquare = dot(z, z);
		++iteration;
	}

	//imageStore(IteratorRWTexture, pixelPos, uint4(iteration));
	float3 color = (iteration == MaxIteration) ? float3(0,0,0) : TEXTURE_SAMPLE(ColorMapTexture, float(iteration) / float(MaxIteration) * ColorMapParam.x * 50 + ColorMapParam.y).rgb;


	float d = float(iteration) / float(MaxIteration);
#if COMPILER_HLSL
	ColorRWTexture[pixelPos] = float4(color, 1);
	//ColorRWTexture[pixelPos] = float4(Test, 1);
#else
	imageStore(ColorRWTexture, pixelPos, float4( color , 1 ) );
	//imageStore(ColorRWTexture, pixelPos, float4( float(iteration) / float(100) ));
	//imageStore(ColorRWTexture, pixelPos, float4(float(100) / float(100)));
#endif


}

#endif