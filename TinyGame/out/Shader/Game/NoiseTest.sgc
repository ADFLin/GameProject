#include "Common.sgc"
#include "ScreenVertexShader.sgc"
#include "NoiseCommon.sgc"

uniform float Time;
uniform sampler2D RandTexture;
uniform sampler2D NoiseTexture;
uniform sampler3D VolumeTexture;

#ifndef USE_RAND_TEXTURE
#define USE_RAND_TEXTURE 1
#endif
#ifndef USE_FBM_FACTOR
#define USE_FBM_FACTOR 0
#endif

#define TEX_SIZE 512.0

float MyRandom(float2 uv)
{
#if USE_RAND_TEXTURE
	return texture2D(RandTexture, uv / TEX_SIZE).x;
#else

	return PseudoRandom(uv);

#endif
}


float SimpleNoise(float2 uv)
{
	float2 i = floor(uv) + float2(0.5);
	float2 f = frac(uv);

	// Four corners in 2D of a tile
	float a = MyRandom(i);
	float b = MyRandom(i + float2(1.0, 0.0));
	float c = MyRandom(i + float2(0.0, 1.0));
	float d = MyRandom(i + float2(1.0, 1.0));

	float2 u = PerlinFade(f);

#if 0
	return lerp(a, b, u.x) +
		(c - a)* u.y * (1.0 - u.x) +
		(d - b) * u.x * u.y;
#else
	return lerp(lerp(a, b, u.x), lerp(c, d, u.x), u.y);

#endif
}


uniform float4 FBMFactor;
float FBM(float2 uv, int numOctaves)
{
	float v = 0.0;
	float a = 0.5;
#if USE_FBM_FACTOR
	float2 shift = float2(FBMFactor.x);
	// Rotate to reduce axial bias
	float2x2 rot = FBMFactor.y * float2x2(cos(FBMFactor.z), sin(FBMFactor.z),
					                     -sin(FBMFactor.z), cos(FBMFactor.z));
#else
	float2 shift = float2(100.0);
	// Rotate to reduce axial bias
	float2x2 rot = float2x2(cos(0.5), sin(0.5),
							-sin(0.5), cos(0.50));
#endif
	for( int i = 0; i < numOctaves; ++i )
	{
		v += a * SimpleNoise(uv);
		uv = rot * uv * 2.0 + shift;
		a *= 0.5;
	}
	return v;
}

float F(float2 uv, int numOctaves)
{
	return FBM(uv + FBM(uv + FBM(uv, numOctaves), numOctaves), numOctaves);
}

#if PIXEL_SHADER

in VSOutput vsOutput;
layout(location = 0) out float4 OutColor;
void MainPS()
{
#if USE_FBM_FACTOR
	int numOctaves = int(FBMFactor.w);
#else
	int numOctaves = 5;
#endif
	float2 st = vsOutput.UVs * 10.;
	// st += st * abs(sin(u_time*0.1)*3.0);
	float3 color = float3(0.0);

	float2 q = float2(0.);
	q.x = F(st + 0.00*Time, numOctaves);
	q.y = F(st + float2(1.0), numOctaves);

	float2 r = float2(0.);
	r.x = FBM(st + 1.0*q + float2(1.7, 9.2) + 0.15*Time, numOctaves);
	r.y = FBM(st + 1.0*q + float2(8.3, 2.8) + 0.126*Time, numOctaves);

	float f = FBM(st + r, numOctaves);

	color = lerp(vec3(0.101961, 0.619608, 0.666667),
				vec3(0.666667, 0.666667, 0.498039),
				clamp((f*f)*4.0, 0.0, 1.0));

	color = lerp(color,
				vec3(0, 0, 0.164706),
				clamp(length(q), 0.0, 1.0));

	color = lerp(color,
				vec3(0.666667, 1, 1),
				clamp(length(r.x), 0.0, 1.0));

	float v = MyRandom(0.01*vsOutput.UVs);

	v = SimpleNoise(5*vsOutput.UVs);

	v = FBM(st, numOctaves);
	v = F(st + Time, numOctaves);
	//v = FBM(3 * vsOutput.UVs,5);
	OutColor = float4(v, v, v, 1);
	//OutColor = float4(color, 1);
	

	//OutColor = float4(1, v, v, 1);
}


float FBMTest(float2 uv , int octaves)
{
	float result = 0;
	float amp = 1.0;
	float total = 0;

	float2 shift = float2(FBMFactor.x);
	// Rotate to reduce axial bias

	float c, s;
	sincos(FBMFactor.z, s, c);
	float2x2 rot = FBMFactor.y * float2x2(c, s,
										  -s,c);

	for( int i = 0; i < octaves; ++i )
	{
		result += amp *  texture2D(NoiseTexture, uv).x;
		uv = rot * uv * 2.0 + shift;
		//uv *= 2;
		total += amp;
		amp *= 0.5;
	}
	return result / total;
}

void TestPS()
{

	float noise = texture2D(NoiseTexture, vsOutput.UVs).x;
	OutColor = float4(noise.xxx, 1);


	OutColor = float4(FBMTest(vsOutput.UVs, 3).xxx, 1);
	float v = texture3D(VolumeTexture, float3(vsOutput.UVs,0.5)).x;
	OutColor = float4(v.xxx, 1);
	//OutColor = float4(1,1,0, 1);

}

#endif

