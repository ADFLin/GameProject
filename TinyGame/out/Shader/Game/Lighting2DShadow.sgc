#include "Common.sgc"

struct VSOutputParams
{
	float4 data MEMBER_OUTPUT(TEXCOORD0);
};

#if VERTEX_SHADER

VS_ENTRY_START(MainVS)
	VS_INPUT(float2 InPos, ATTRIBUTE_POSITION)
	VS_OUTPUT_STRUCT(VSOutputParams VSOutput , 0)
VS_ENTRY_END(MainVS)
{
	SvPosition = float4(InPos, 0, 1.0);
	VSOutput.data = float4(1, 1, 1, 1);
}
#endif //VERTEX_SHADER

#if GEOMETRY_SHADER

uniform float2 LightLocation;
uniform float2 ScreenSize;
float4 TransformToNDC(float2 pos)
{
	return float4(2 * (pos / ScreenSize) - 1, 0, 1);
}

struct GSOutputParams
{
	GS_NO_MEMBER_PARAM
	GS_SV_POSTITION_OUT
};


#if COMPILER_GLSL
layout(location = 0) in VSOutputParams VSOutputs[2];
layout(lines, invocations = 1) in;
layout(triangle_strip, max_vertices = 4) out;
layout(location = 0) out GSOutputParams GSOutput;
void MainGS()
{
#else
[instance(1)]
[maxvertexcount(4)]
void MainGS(line float4 SvPositions[2] : SV_POSITION, line VSOutputParams VSOutputs[2], inout TriangleStream< GSOutputParams > OutputStream)
{
#endif

	float2 cur = GS_SVPOSITION(1).xy;
	float2 prev = GS_SVPOSITION(0).xy;
	float2 edge = cur - prev;
	float2 dirCur = cur - LightLocation;
	float2 dirPrev = prev - LightLocation;
	if( dirCur.x * edge.y - dirCur.y * edge.x < 0 )
	{
		GSOutputParams params;
		GS_EMIT_VERTEX(TransformToNDC(prev), params);
		GS_EMIT_VERTEX(TransformToNDC(cur), params);
		GS_EMIT_VERTEX(TransformToNDC(prev + 1000 * dirPrev), params);
		GS_EMIT_VERTEX(TransformToNDC(cur + 1000 * dirCur), params);
		GS_END_PRIMITIVE;
	}
}

#endif //GEOMETRY_SHADER


#if PIXEL_SHADER

PS_ENTRY_START(MainPS)
	PS_OUTPUT(float4 OutColor , 0)
PS_ENTRY_END(MainPS)
{
	OutColor = float4(0.1, 0, 0, 1);
}

#endif //PIXEL_SHADER